<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-cn">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="多线程的数据安全除了锁能解决，还可以通过gcd的一些方法来解决：比如 异步串行队列、信号量、dispatch_barrier_async、dispatch_group_t…现在可以通过源码+例子 来了解一下它们。当然，还有一个学习gcd的一个好的方法就是看一下 TMCache的源码。">
<meta property="og:type" content="article">
<meta property="og:title" content="线程安全之gcd">
<meta property="og:url" content="http://yoursite.com/2017/07/12/20170712线程安全之gcd/index.html">
<meta property="og:site_name" content="iKiwi">
<meta property="og:description" content="多线程的数据安全除了锁能解决，还可以通过gcd的一些方法来解决：比如 异步串行队列、信号量、dispatch_barrier_async、dispatch_group_t…现在可以通过源码+例子 来了解一下它们。当然，还有一个学习gcd的一个好的方法就是看一下 TMCache的源码。">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-06-22T03:32:12.590Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程安全之gcd">
<meta name="twitter:description" content="多线程的数据安全除了锁能解决，还可以通过gcd的一些方法来解决：比如 异步串行队列、信号量、dispatch_barrier_async、dispatch_group_t…现在可以通过源码+例子 来了解一下它们。当然，还有一个学习gcd的一个好的方法就是看一下 TMCache的源码。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/12/20170712线程安全之gcd/">





  <title>线程安全之gcd | iKiwi</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">iKiwi</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/12/20170712线程安全之gcd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wangdetong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="iKiwi">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">线程安全之gcd</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-12T00:00:00+08:00">
                2017-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>多线程的数据安全除了锁能解决，还可以通过gcd的一些方法来解决：比如 异步串行队列、信号量、dispatch_barrier_async、dispatch_group_t…现在可以通过源码+例子 来了解一下它们。当然，还有一个学习gcd的一个好的方法就是看一下 TMCache的源码。</p>
<a id="more"></a>

<h2 id="dispatch-async"><a href="#dispatch-async" class="headerlink" title="dispatch_async"></a><code>dispatch_async</code></h2><p>对于dispatch_async，我们真是老生常谈了，具体用法就不说了，下面看下部分源码吧。<br>通过源码发现：</p>
<ol>
<li>通过<code>dispatch_continuation_t</code> 管理 group、 queue 、block</li>
<li><code>dispatch_async</code>的标记位是：<code>DISPATCH_OBJ_CONSUME_BIT</code>，注意在 <code>dispatch_barrier_async</code> 时，标记位： <code>DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_BARRIER_BIT</code>。</li>
<li>在函数<code>_dispatch_continuation_async -&gt; _dispatch_continuation_async2</code> 中，判断flag是不是 barrier （通过标记位 &amp; <code>DISPATCH_OBJ_BARRIER_BIT</code> ）？<br> 是：就直接调用<code>_dispatch_continuation_push</code>(类似把block放在queue里)，<br> 不是：就调用<code>_dispatch_async_f2</code>（类似异步执行）</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT;</span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc);</span><br><span class="line">&#125;</span><br><span class="line">_dispatch_continuation_init(dispatch_continuation_t dc,</span><br><span class="line">		dispatch_queue_class_t dqu, dispatch_block_t work,</span><br><span class="line">		pthread_priority_t pp, dispatch_block_flags_t flags, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dc-&gt;dc_flags = dc_flags | DISPATCH_OBJ_BLOCK_BIT;</span><br><span class="line">	dc-&gt;dc_ctxt = _dispatch_Block_copy(work);</span><br><span class="line">	<span class="comment">// 省略…</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _dispatch_continuation_async(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_continuation_async2(dq, dc,</span><br><span class="line">			dc-&gt;dc_flags &amp; DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_async2(<span class="built_in">dispatch_queue_t</span> dq, dispatch_continuation_t dc,</span><br><span class="line">		<span class="keyword">bool</span> barrier)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fastpath(barrier || !DISPATCH_QUEUE_USES_REDIRECTION(dq-&gt;dq_width))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_push(dq, dc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a><code>dispatch_semaphore_t</code></h2><p>在之前的《线程安全之锁》中谈到过 semaphore，把semaphore的value值设置为0 可以当做 mutex 来使用，其实 semaphore 真正属于的gcd里面的。这里就看看semaphore实现的源码。</p>
<h3 id="dispatch-semaphore-create"><a href="#dispatch-semaphore-create" class="headerlink" title="dispatch_semaphore_create"></a><code>dispatch_semaphore_create</code></h3><p>很简单的逻辑</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t dispatch_semaphore_create(<span class="keyword">long</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_semaphore_t dsema;</span><br><span class="line">	<span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">	&#125;</span><br><span class="line">	dsema = (dispatch_semaphore_t)_dispatch_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_semaphore_s));</span><br><span class="line">	_dispatch_semaphore_class_init(value, dsema);</span><br><span class="line">	dsema-&gt;dsema_orig = value;</span><br><span class="line">	<span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a><code>dispatch_semaphore_wait</code></h3><blockquote>
<p>Decrement the counting semaphore. If the resulting value is less than zero, this function waits for a signal to occur before returning.</p>
</blockquote>
<ul>
<li>信号量的value -1</li>
<li>最终会调用 内核的dispatch_sema4_wait函数，阻塞当前线程直到出现一个signal</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (fastpath(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(dispatch_semaphore_t dsema,</span><br><span class="line">		dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> orig;</span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="comment">// 省略...</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">		_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-semaphore-signal"><a href="#dispatch-semaphore-signal" class="headerlink" title="dispatch_semaphore_signal"></a>dispatch_semaphore_signal</h3><blockquote>
<p>If the previous value was less than zero, this function wakes a process currently waiting.</p>
</blockquote>
<ul>
<li>让信号量的value +1</li>
<li>最终会调用 调用内核的 _dispatch_sema4_signal 函数唤醒线程，然后返回 1。</li>
<li>也符合文档中的描述:“如果唤醒了线程，返回非 0，否则返回 0”。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _dispatch_semaphore_signal_slow(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	_dispatch_sema4_signal(&amp;dsema-&gt;dsema_sema, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">	<span class="keyword">if</span> (fastpath(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_semaphore_signal()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TMCache中的简单用法"><a href="#TMCache中的简单用法" class="headerlink" title="TMCache中的简单用法"></a>TMCache中的简单用法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    __block <span class="keyword">id</span> objectForKey = <span class="literal">nil</span>;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span> objectForKey:key block:^(TMCache *cache, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> object) &#123;</span><br><span class="line">        objectForKey = object;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="meta">#if !OS_OBJECT_USE_OBJC</span></span><br><span class="line">    dispatch_release(semaphore);</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> objectForKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-barrier-a-sync"><a href="#dispatch-barrier-a-sync" class="headerlink" title="dispatch_barrier (a)sync"></a><code>dispatch_barrier (a)sync</code></h2><p>看过 TMCache源码发现，其中大量使用了 dispatch_barrier_async，这里就通过 源码+例子 的形式了解一下 dispatch_barrier。</p>
<p>作用：等前面的执行完了 -&gt; 再执行brrier -&gt; 后面的任务。</p>
<h3 id="dispatch-barrier-a-sync-基本功能-amp-用法"><a href="#dispatch-barrier-a-sync-基本功能-amp-用法" class="headerlink" title="dispatch_barrier (a)sync 基本功能&amp;用法"></a>dispatch_barrier (a)sync 基本功能&amp;用法</h3><p>针对并发队列，但是全局队列除外，如果使用串行队列或全局队列，dispatch_barrier_async就和dispatch_async 函数效果了。<br>dispatch_barrier_(a)sync 与 dispatch_(a)sync是一个道理的，sync阻碍当前线程，而async不阻碍。<br>sync会阻碍当前线程，并执行自己的block任务后执行下面的程序，而async不阻碍当前线程，只负责把block任务放到queue里就行了。<br>sync &amp; async都会让barrier生效，阻碍queue 里的任务</p>
<h4 id="async-barrier-demo"><a href="#async-barrier-demo" class="headerlink" title="async barrier demo"></a>async barrier demo</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) testBarrierBlock &#123;   </span><br><span class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentQueue = dispatch_queue_create(<span class="string">"myConcurrentQueue"</span>,DISPATCH_QUEUE_CONCURRENT);<span class="comment">// 需要自己创建</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;<span class="comment">// 1、2是并行的</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_barrier_async(myConcurrentQueue, ^&#123;<span class="comment">// 等1.2都执行完便会执行此方法，此时便会将线程延迟直至barrier执行完毕方可</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch barrier"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;<span class="comment">// 3、4是并行的</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sync-barrier-demo"><a href="#sync-barrier-demo" class="headerlink" title="sync barrier demo"></a>sync barrier demo</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> myConcurrentQueue = dispatch_queue_create(<span class="string">"myConcurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);<span class="comment">// 需要自己创建</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;<span class="comment">// 1.2是并行的       </span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_barrier_sync(myConcurrentQueue, ^&#123;<span class="comment">// 把sync改为async查看打印对比</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch barrier"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 3"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(myConcurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"dispatch test 4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"just for test sync &amp; async"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"just for test sync &amp; async"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"just for test sync &amp; async"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"just for test sync &amp; async"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"just for test sync &amp; async"</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"just for test sync &amp; async"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="barrier实现-name线程安全"><a href="#barrier实现-name线程安全" class="headerlink" title="barrier实现 name线程安全"></a>barrier实现 name线程安全</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</span><br><span class="line">        _name = [name <span class="keyword">copy</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    __block <span class="built_in">NSString</span> *tempName;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</span><br><span class="line">        tempName = _name;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tempName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TMCache中对-dispatch-barrier-async-的使用"><a href="#TMCache中对-dispatch-barrier-async-的使用" class="headerlink" title="TMCache中对 dispatch_barrier_async 的使用"></a>TMCache中对 dispatch_barrier_async 的使用</h4><p>TMMemoryCache 在设计时，主要目标是线程安全，它把所有读写操作都放到了同一个 concurrent queue 中，然后用 dispatch_barrier_async 来保证任务能顺序执行<br>举个🌰</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key block:(TMMemoryCacheObjectBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    __<span class="keyword">weak</span> TMMemoryCache *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line">        TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">        <span class="keyword">if</span> (!strongSelf)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        [strongSelf removeObjectAndExecuteBlocksForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            __<span class="keyword">weak</span> TMMemoryCache *weakSelf = strongSelf;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(strongSelf-&gt;_queue, ^&#123;</span><br><span class="line">                TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">                <span class="keyword">if</span> (strongSelf)</span><br><span class="line">                    block(strongSelf, key, <span class="literal">nil</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-barrier-async-部分源码"><a href="#dispatch-barrier-async-部分源码" class="headerlink" title="dispatch_barrier_async 部分源码"></a>dispatch_barrier_async 部分源码</h3><ol>
<li>对比源码 dispatch_barrier_async &amp; dispatch_async 发现:<br>前者的标记位为DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_BARRIER_BIT，后者为DISPATCH_OBJ_CONSUME_BIT<br>前者直接调用了 _dispatch_continuation_push，后者调用了_dispatch_continuation_async -&gt; 满足条件再调用_dispatch_continuation_push</li>
<li>从队列中取出任务时会用到标记位：<br>循环拿出所有的任务，依次调用 _dispatch_continuation_redirect最终并行处理。一旦遇到DISPATCH_OBJ_BARRIER_BIT这个标记，就会终止循环。在 out 标签后面，返回了一个空的信号量，随后方法的调用者会把它单独放入队列，等待下一次执行。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_BARRIER_BIT;</span><br><span class="line">	_dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-group-t"><a href="#dispatch-group-t" class="headerlink" title="dispatch_group_t"></a>dispatch_group_t</h2><blockquote>
<p>Grouping blocks allows for aggregate synchronization. Your application can submit multiple blocks and track when they all complete, even though they might run on different queues. This behavior can be helpful when progress can’t be made until all of the specified tasks are complete.</p>
</blockquote>
<p>dispatch_group提供了多个block之间的同步机制，可以在多个block都执行完成之后再执行有依赖的任务(一般用于：当并发队列的中所有的任务执行完成后 最后再去做某种任务！；而串行队列直接把 那个任务 放在队列的最后就行！)<br>dispatch_group可以管理不同类型的queue，👇下面为了测试方便用了同一个queue</p>
<h3 id="dispatch-group-t基本功能-amp-用法"><a href="#dispatch-group-t基本功能-amp-用法" class="headerlink" title="dispatch_group_t基本功能&amp;用法"></a>dispatch_group_t基本功能&amp;用法</h3><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t dispatch_group_create(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">void</span> dispatch_group_async(dispatch_group_t group,<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br><span class="line"><span class="comment">// dispatch_group_enter和dispatch_group_leave需要成对出现</span></span><br><span class="line"><span class="keyword">void</span> dispatch_group_enter(dispatch_group_t group);</span><br><span class="line"><span class="keyword">void</span> dispatch_group_leave(dispatch_group_t group);</span><br><span class="line"><span class="comment">// 等待组任务完成，会阻塞当前线程，当任务组执行完毕时，才会解除阻塞当前线程</span></span><br><span class="line"><span class="keyword">long</span> dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</span><br><span class="line"><span class="comment">// 待任务组执行完毕时调用，不会阻塞当前线程</span></span><br><span class="line"><span class="keyword">void</span> dispatch_group_notify(dispatch_group_t group,<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>

<h4 id="group里没有嵌套异步任务"><a href="#group里没有嵌套异步任务" class="headerlink" title="group里没有嵌套异步任务"></a>group里没有嵌套异步任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;    </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"任务一"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line"> dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"任务二"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"任务二"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> dispatch_group_notify(group, concurrentQueue, ^&#123;</span><br><span class="line"> 	<span class="built_in">NSLog</span>(<span class="string">@" done "</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="当group里含有嵌套异步操作时，需要引入leave-、enter"><a href="#当group里含有嵌套异步操作时，需要引入leave-、enter" class="headerlink" title="当group里含有嵌套异步操作时，需要引入leave 、enter"></a>当group里含有嵌套异步操作时，需要引入leave 、enter</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;    </span><br><span class="line">	dispatch_group_enter(group);<span class="comment">// 底层：信号量 +1</span></span><br><span class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    	sleep(<span class="number">1</span>); <span class="comment">//这里线程睡眠1秒钟，模拟异步请求</span></span><br><span class="line">    	<span class="built_in">NSLog</span>(<span class="string">@"日程详情 下载成功"</span>);</span><br><span class="line">    	dispatch_group_leave(group);<span class="comment">// 底层：信号量 -1</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;    </span><br><span class="line">	dispatch_group_enter(group);</span><br><span class="line">	<span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    	sleep(<span class="number">1</span>); <span class="comment">//这里线程睡眠1秒钟，模拟异步请求</span></span><br><span class="line">    	<span class="built_in">NSLog</span>(<span class="string">@"评论内容 下载成功"</span>);</span><br><span class="line">    	dispatch_group_leave(group);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"hahaha"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	<span class="comment">// 都下载完成后 更新UI！</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"notify:load finished"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="TMCache-中关于-group-的例子"><a href="#TMCache-中关于-group-的例子" class="headerlink" title="TMCache 中关于 group 的例子"></a>TMCache 中关于 group 的例子</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> &lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key block:(TMCacheObjectBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!key || !object)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dispatch_group_t group = <span class="literal">nil</span>;</span><br><span class="line">    TMMemoryCacheObjectBlock memBlock = <span class="literal">nil</span>;</span><br><span class="line">    TMDiskCacheObjectBlock diskBlock = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        group = dispatch_group_create();</span><br><span class="line">        dispatch_group_enter(group);</span><br><span class="line">        dispatch_group_enter(group);</span><br><span class="line">        </span><br><span class="line">        memBlock = ^(TMMemoryCache *cache, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> object) &#123;</span><br><span class="line">            dispatch_group_leave(group);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        diskBlock = ^(TMDiskCache *cache, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> &lt;<span class="built_in">NSCoding</span>&gt; object, <span class="built_in">NSURL</span> *fileURL) &#123;</span><br><span class="line">            dispatch_group_leave(group);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_memoryCache setObject:object forKey:key block:memBlock];</span><br><span class="line">    [_diskCache setObject:object forKey:key block:diskBlock];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (group) &#123;</span><br><span class="line">        __<span class="keyword">weak</span> TMCache *weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        dispatch_group_notify(group, _queue, ^&#123;</span><br><span class="line">            TMCache *strongSelf = weakSelf;</span><br><span class="line">            <span class="keyword">if</span> (strongSelf)</span><br><span class="line">                block(strongSelf, key, object);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="meta">#if !OS_OBJECT_USE_OBJC</span></span><br><span class="line">        dispatch_release(group);</span><br><span class="line">        <span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatch-group-t-部分源码"><a href="#dispatch-group-t-部分源码" class="headerlink" title="dispatch_group_t 部分源码"></a>dispatch_group_t 部分源码</h3><h4 id="dispatch-group-create"><a href="#dispatch-group-create" class="headerlink" title="dispatch_group_create"></a><code>dispatch_group_create</code></h4><ul>
<li>group 就是 信号量</li>
<li>group作为信号量的value 为0，好像旧版本value是LONG-MAX</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> dispatch_group_t _dispatch_group_create_with_count(<span class="keyword">long</span> count)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_t dg = (dispatch_group_t)_dispatch_alloc(</span><br><span class="line">			DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_group_s));</span><br><span class="line">	_dispatch_semaphore_class_init(count, dg);</span><br><span class="line">	<span class="keyword">if</span> (count) &#123;</span><br><span class="line">		os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_t dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_group_create_with_count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_semaphore_class_init(<span class="keyword">long</span> value, dispatch_semaphore_class_t dsemau)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> dispatch_semaphore_header_s *dsema = dsemau._dsema_hdr;</span><br><span class="line">	dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dsema-&gt;do_targetq = _dispatch_get_root_queue(DISPATCH_QOS_DEFAULT, <span class="literal">false</span>);</span><br><span class="line">	dsema-&gt;dsema_value = value;</span><br><span class="line">	_dispatch_sema4_init(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-group-enter"><a href="#dispatch-group-enter" class="headerlink" title="dispatch_group_enter"></a>dispatch_group_enter</h4><p>其内部调用宏定义方法os_atomic_inc_orig2o，也就是让 信号量的value increment 1</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_group_enter(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_inc_orig2o(dg, dg_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (slowpath((<span class="keyword">unsigned</span> <span class="keyword">long</span>)value &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)LONG_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">"Too many nested calls to dispatch_group_enter()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (value == <span class="number">0</span>) &#123;</span><br><span class="line">		_dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#define os_atomic_inc_orig2o(p, f, m) \</span></span><br><span class="line">		os_atomic_add_orig2o(p, f, <span class="number">1</span>, m)</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-group-leave"><a href="#dispatch-group-leave" class="headerlink" title="dispatch_group_leave"></a>dispatch_group_leave</h4><p>其内部调用宏定义方法os_atomic_dec2o，也就是让 信号量的value decrement 1<br>如果信号量的value == 0，就是与初始值一致，就唤醒group</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_group_leave(dispatch_group_t dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_dec2o(dg, dg_value, release);</span><br><span class="line">	<span class="keyword">if</span> (slowpath(value == <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">void</span>)_dispatch_group_wake(dg, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">"Unbalanced call to dispatch_group_leave()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h4><blockquote>
<p>dispatch_group_async -&gt; _dispatch_continuation_group_async -&gt; dispatch_group_enter 其目的是让 信号量的value +1，猜测 在 block执行之后，信号量的value -1</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq, dispatch_block_t db)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dc = _dispatch_continuation_alloc();</span><br><span class="line">	uintptr_t dc_flags = DISPATCH_OBJ_CONSUME_BIT | DISPATCH_OBJ_GROUP_BIT;</span><br><span class="line">	_dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_group_async(dg, dq, dc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_group_async(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_continuation_t dc)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_group_enter(dg);</span><br><span class="line">	dc-&gt;dc_data = dg;</span><br><span class="line">	_dispatch_continuation_async(dq, dc); <span class="comment">//...TODO...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-group-notify"><a href="#dispatch-group-notify" class="headerlink" title="dispatch_group_notify"></a>dispatch_group_notify</h4><p>dsn-&gt;do_next = NULL：标记block在执行链表的尾部，等待group的所有block执行完再执行这个block</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> dispatch_group_notify(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_block_t db)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_continuation_t dsn = _dispatch_continuation_alloc();</span><br><span class="line">	_dispatch_continuation_init(dsn, dq, db, <span class="number">0</span>, <span class="number">0</span>, DISPATCH_OBJ_CONSUME_BIT);</span><br><span class="line">	_dispatch_group_notify(dg, dq, dsn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_group_notify(dispatch_group_t dg, <span class="built_in">dispatch_queue_t</span> dq,</span><br><span class="line">		dispatch_continuation_t dsn)</span><br><span class="line">&#123;</span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line">	<span class="comment">// 省略…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h4><p>group_wait的中有 <code>_dispatch_sema4_create &amp; _dispatch_sema4_wait</code> 可以简单的理解为 用信号量 进行等待，阻碍当前线程，等待group中的所有事件完成。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> dispatch_group_wait(dispatch_group_t dg, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (dg-&gt;dg_value == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_group_wait_slow(dg, timeout);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(dispatch_group_t dg, dispatch_time_t timeout)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	_dispatch_sema4_create(&amp;dg-&gt;dg_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="comment">// 省略…</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">		_dispatch_sema4_wait(&amp;dg-&gt;dg_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">深入理解GCD</a><br><a href="https://github.com/tumblr/TMCache" target="_blank" rel="noopener">TMCache</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/11/20170611线程安全之锁/" rel="next" title="线程安全之锁">
                <i class="fa fa-chevron-left"></i> 线程安全之锁
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/25/20170825app瘦身之移除无用macho文件/" rel="prev" title="app瘦身之移除无用macho文件">
                app瘦身之移除无用macho文件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8yOTMzNy81OTA1"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wangdetong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-async"><span class="nav-number">1.</span> <span class="nav-text">dispatch_async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-semaphore-t"><span class="nav-number">2.</span> <span class="nav-text">dispatch_semaphore_t</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-semaphore-create"><span class="nav-number">2.1.</span> <span class="nav-text">dispatch_semaphore_create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-semaphore-wait"><span class="nav-number">2.2.</span> <span class="nav-text">dispatch_semaphore_wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-semaphore-signal"><span class="nav-number">2.3.</span> <span class="nav-text">dispatch_semaphore_signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TMCache中的简单用法"><span class="nav-number">2.4.</span> <span class="nav-text">TMCache中的简单用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-barrier-a-sync"><span class="nav-number">3.</span> <span class="nav-text">dispatch_barrier (a)sync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-a-sync-基本功能-amp-用法"><span class="nav-number">3.1.</span> <span class="nav-text">dispatch_barrier (a)sync 基本功能&amp;用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#async-barrier-demo"><span class="nav-number">3.1.1.</span> <span class="nav-text">async barrier demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sync-barrier-demo"><span class="nav-number">3.1.2.</span> <span class="nav-text">sync barrier demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#barrier实现-name线程安全"><span class="nav-number">3.1.3.</span> <span class="nav-text">barrier实现 name线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TMCache中对-dispatch-barrier-async-的使用"><span class="nav-number">3.1.4.</span> <span class="nav-text">TMCache中对 dispatch_barrier_async 的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-barrier-async-部分源码"><span class="nav-number">3.2.</span> <span class="nav-text">dispatch_barrier_async 部分源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-group-t"><span class="nav-number">4.</span> <span class="nav-text">dispatch_group_t</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-group-t基本功能-amp-用法"><span class="nav-number">4.1.</span> <span class="nav-text">dispatch_group_t基本功能&amp;用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关函数"><span class="nav-number">4.1.1.</span> <span class="nav-text">相关函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#group里没有嵌套异步任务"><span class="nav-number">4.1.2.</span> <span class="nav-text">group里没有嵌套异步任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当group里含有嵌套异步操作时，需要引入leave-、enter"><span class="nav-number">4.1.3.</span> <span class="nav-text">当group里含有嵌套异步操作时，需要引入leave 、enter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TMCache-中关于-group-的例子"><span class="nav-number">4.1.4.</span> <span class="nav-text">TMCache 中关于 group 的例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-group-t-部分源码"><span class="nav-number">4.2.</span> <span class="nav-text">dispatch_group_t 部分源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group-create"><span class="nav-number">4.2.1.</span> <span class="nav-text">dispatch_group_create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group-enter"><span class="nav-number">4.2.2.</span> <span class="nav-text">dispatch_group_enter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group-leave"><span class="nav-number">4.2.3.</span> <span class="nav-text">dispatch_group_leave</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group-async"><span class="nav-number">4.2.4.</span> <span class="nav-text">dispatch_group_async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group-notify"><span class="nav-number">4.2.5.</span> <span class="nav-text">dispatch_group_notify</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-group-wait"><span class="nav-number">4.2.6.</span> <span class="nav-text">dispatch_group_wait</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangdetong</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
